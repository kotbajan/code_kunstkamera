# postgresql

## docker compose
[dockerhub](https://hub.docker.com/_/postgres)

## questions

```sql
create table task_statuses (
    status_id   int     primary key generated by default as identity,
    name        text                    not null,
    available   boolean not null
);
insert into task_statuses(status_id, name, available) values 
(1, 'TODO', true), 
(3, 'DONE', false);
create table tasks (
    task_id     int     primary key generated always as identity,
    assign_to   int                         null,
    status_id   int                     not null,
	description text                    not null
);
insert into tasks(status_id, description) values
(1, 'Написать код'),
(1, 'Написать тесты'),
(2, 'Запустить тесты'),
(1, 'Установить на сервер');
```

### Выборка с блокировкой
Запрос выполняется 2 разными пользователями в транзакциях
```sql
select t.*
from tasks t, task_statuses ts
where t.status_id = ts.status_id
and ts.available = true
order by t.task_id
for update skip locked
limit 1;
```
Ожидание: каждый пользователь получает по одной записи и эта запись заблокирована
Факт: первый пользователь получает запись, а второй получает пустой список

```

task_id|assign_to|status_id|description |created_at             |
-------+---------+---------+------------+-----------------------+
      4|         |        1|Написать код|2023-07-23 19:26:53.037|


QUERY PLAN                                                                                                                                                   |
-------------------------------------------------------------------------------------------------------------------------------------------------------------+
Limit  (cost=0.30..0.87 rows=1 width=101) (actual time=0.031..0.032 rows=1 loops=1)                                                                          |
  Output: t.task_id, t.assign_to, t.status_id, t.description, t.created_at, ts.status_id, ts.name, ts.available, t.ctid, ts.ctid                             |
  ->  LockRows  (cost=0.30..289.89 rows=510 width=101) (actual time=0.030..0.031 rows=1 loops=1)                                                             |
        Output: t.task_id, t.assign_to, t.status_id, t.description, t.created_at, ts.status_id, ts.name, ts.available, t.ctid, ts.ctid                       |
        ->  Nested Loop  (cost=0.30..284.79 rows=510 width=101) (actual time=0.029..0.029 rows=1 loops=1)                                                    |
              Output: t.task_id, t.assign_to, t.status_id, t.description, t.created_at, ts.status_id, ts.name, ts.available, t.ctid, ts.ctid                 |
              Inner Unique: true                                                                                                                             |
              ->  Index Scan using tasks_pkey on public.tasks t  (cost=0.15..63.45 rows=1020 width=58) (actual time=0.016..0.016 rows=1 loops=1)             |
                    Output: t.task_id, t.assign_to, t.status_id, t.description, t.created_at, t.ctid                                                         |
              ->  Index Scan using task_statuses_pkey on public.task_statuses ts  (cost=0.15..0.22 rows=1 width=43) (actual time=0.011..0.011 rows=1 loops=1)|
                    Output: ts.status_id, ts.name, ts.available, ts.ctid                                                                                     |
                    Index Cond: (ts.status_id = t.status_id)                                                                                                 |
                    Filter: ts.available                                                                                                                     |
Planning Time: 0.097 ms                                                                                                                                      |
Execution Time: 0.096 ms                                                                                                                                     |
```

Ответ: причина в блокировке записи статусов, нужно указать конкретную таблицу для блокировки и убрать декартово произведение (pg его оптимизирует, но всё равно)
```sql
select *
from tasks t
join task_statuses ts
on (t.status_id = ts.status_id)
where ts.available = true
order by t.task_id
for update of t skip locked
limit 1;
```

# Соединения
Как найти задачи, для которых указаны несуществующие id статусов

Ответ
```sql
select *
from tasks t
left join task_statuses ts
on (t.status_id = ts.status_id)
where ts.status_id is null;
```

Как найти id статусов у которых больше 2 записей

```sql
select t.status_id, count(0)
from tasks t
group by t.status_id
having count(0) > 2
```